# Чем занимаются программисты?

Привет! 

В заметках я попытаюсь объяснить людям, далеким от it, чем занимаются программисты.

В объяснениях допустимы неточности для упрощения материала.

Содержание:
* [Основы](#основы)
  * [Что такое компьютер](#что-такое-компьютер)
  * [Основы счисления](#основы-счисления)
  * [Размерности](#размерности)
* [Разработка](#разработка)
  * [Разновидности языков](#разновидности-языков)
  * [ООП](#объектно-ориентированное-программирование)
    * [Абстракция](#абстракция)
    * [Инкапсуляция](#инкапсуляция)
    * [Полиморфизм](#полиморфизм)

# Основы
## Что такое компьютер
Компьютер (**computer, кампуктер, комплюктер** и т.п.) - это набор устройств и компонентов, которые позволяют хранить и обрабатывать данные. 

Книга хранит текст в виде букв на бумаге, фотографии хранят изображение в виде точек цвета на пленке, пластинка хранит музыку в виде канавок в пластмассе, арифмометр умеет складывать числа. Умные дядьки-инженеры в середине ХХ века все собрали вместе, потихоньку привели к одному формату хранения данных и получили современный компьютер.

### Внешний вид
Обычно компьютер выглядит как **десктоп (desktop, системный блок)**, **ноутбук(notebook)** или **сервер(server)**.

Когда говорят "Компьютер", обычно подразумевают десктоп: прямоугольный ящик, рядом экран, мышь и клавиатура. Классика. Экран называется монитор (**monitor**), прямоугольный ящик - системный блок (**system unit**). Иногда системный блок называют процессором, это неправильно - как называть машину мотором. 

В ноутбуке объединили системный блок, монитор, клавиатуру, колонки, веб-камеру. Обычно легче, меньше, дороже и слабее по сравнению с десктопом.

Сервер это такой промышленный компьютер. Сервера обычно мощные, дорогие, капризные и требуют специально обученных людей для обслуживания. Обычно сервера стоят в стойках в холодной чистой комнате и управляются удаленно. Такая комната называется серверная (**server room**). Если серверов много (сотни, тысячи), то строится специальное здание - датацентр (**datacenter**).

### Состав
Системный блок состоит из: 
* корпуса,
* блока питания,
* материнской платы, на которой крепятся все потроха,
* процессора - штуки, которая считает,
* памяти - там где процессор хранит то, что обсчитывает прямо вот щас,
* накопителей - долговременное хранение, все фоточки с морей,
  * hdd - магнитные блины, над ними бегает считывающая головка, как виниловые проигрыватели,
  * ssd - большая флешка,
* видеокарта - плата со своми процессором и памятью для этих ваших игр и прочего видеомонтажа.

__**Усложняющее уточнение**__
> Конфигурация может различаться, например, тонкие клиенты могут не содержать накопителя, сервер может не иметь видеокарты, а рабочая станция иметь 2 процессора и 3 видеокарты.

Ну и зачем нужны все эти потроха?

### Пример
Представьте тетеньку-бухгалтера. Ей надо посчитать ведомости за 68 лет.

Ведомости лежат в архиве - это старый страшный подвал, где стоят стеллажи с папками.

Естественно тетеньке неохота сидеть и считать прямо там, у нее есть уютный теплый кабинет с чайником, окном и фикусом.
Но кабинет маленький - весь архив не перетащишь. Рабочий стол маленький, удобно работать только с одной папкой. И вообще нечего женщине тяжести таскать.

Тетенька спускается вниз в подвал, находит в стеллаже одну нужную папку, приносит ее в кабинет, начинает работать. Раскладывает листы ведомостей из папки по столу, достает калькулятор. Берет цифры из ведомости, вбивает их в калькулятор, полученные числа опять вносит в ведомости.

Когда одна папка готова, надо отнести ее в подвал и взять другую.

Тетенька-бухгалтер - программный код.

Калькулятор - процессор.

Ведомости - память.

Архив - накопитель.

### Подробнее
#### Процессор
Процессор (**Central Processing Unit, CPU, жарг. Камень** - кремниевой пластина, на которой протравлены транзисторы. Невероятно сложная штука с инженерной точки зрения, но сам по себе процессор это просто калькулятор. Очень-очень быстрый калькулятор. 

Вообще процессор умеет только обращаться к памяти и складывать. 

A = B + C

Чтобы вычесть числа, он добавляет (-) к вычитаемому

A = B + (-C)

#### Память
Память (**Оперативное Запоминающее Устройство, ОЗУ, Random Memory Access, RAM, жарг. Мозги**) - это место, где лежат данные, которые вотпрямщас будут нужны процессору.

Процессор берет данные из памяти, обрабатывает и складывает обратно.

__*Усложняющее уточнение*__
> Чтобы процессор мог обращаться к памяти, ему необходимы контроллеры. Раньше они располагались в набре логики на материнской плате (**Northbridge, Северный Мост**). В современных процессорах контроллеры памяти находятся прямо в кристалле, это ускоряет доступ.
  
Спросите - чего бы не хранить нужные данные прямо в процессоре? Отличный вопрос. Ответ - потому что память занимает много места. Весь кристал процессора размером с ноготок. Один чип памяти такого же размера. А модуль памяти - это плата размером с ладошку, где от 8 (только с одной стороны платы) до 16 (с обоих сторон платы) чипов памяти. Еще плюсы от памяти в отдельных модулях:
- проще охлаждать
- проще наращивать
- проще заменять битые.

Когда память находится в одном кристалле с процессором, это обычно называется микроконтроллером (Micro Controller Unit, MCU). Обычно это встраиваемые решения - всякая бытовая и цифровая техника.


## Основы счисления
### Системы счисления

У людей 10 пальцев на руках, поэтому обычная система счисления для современного человека - десятичная. Если считать палочками, будет так:
``` 
0 = 
1 =  |
2 =  ||
3 =  |||
4 =  ||||
5 =  |||||
6 =  ||||||
7 =  |||||||
8 =  ||||||||
9 =  |||||||||
10 = ||||||||||
11 = |||||||||||
12 = ||||||||||||
```
Заметили что произошло? 10 это сдвиг разряда, количество цифр в числе увеличилось. 

Древние шумеры изборели двенадцатиричную (дюжинами) и шестидесятиричную системы счисления. Поэтому у современных людей  60 секунд в минуте, 60 минут в часе и 2х12 часов в сутках, 360 градусов в окружности.

Мы пользуемся арабскими цифрами и их всего 10 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9). Если система имеет основание больше 10, можно вместо цифр писать какие-нибудь кривульки или буквы.

``` 
0 = 
1 =  |
2 =  ||
3 =  |||
4 =  ||||
5 =  |||||
6 =  ||||||
7 =  |||||||
8 =  ||||||||
9 =  |||||||||
A =  ||||||||||        (10)
B =  |||||||||||       (11)
С =  ||||||||||||      (12)
D =  |||||||||||||     (13)
E =  ||||||||||||||    (14)
F =  |||||||||||||||   (15)
10 = ||||||||||||||||  (16)
11 = ||||||||||||||||| (17)
```
Несложно посчитать свой возраст. Мне например 1E лет.

Понятный всем пример с деньгами. Представьте, что номинал банкноты это и есть основание системы счисления. 
Чтобы набрать 100 рублей с максимальным номиналом банкноты в 10 рублей, понадобится 10 банкнот по 10 рублей. 

10 * 10 = 100

Чтобы набрать 100 рублей с максимальным номиналом банкноты по 16 рублей, понадобится 6 банкнот по 16 и еще 4 рубля. 

16 * 6 + 4 = 100

Или в шестнадцатеричной системе

10 * 6 + 4 = 64

Чем больше основание системы счисления, тем большее число можно написать в меньшее количество цифр. В десятичной системе для записи числа 100 нужно 3 цифры, а в шестнадцатеричной - 2 цифры.

### Двоичная система счисления
Представим, что у нас есть целые числа 5 и 6. Сколько у нас возможных значений от 5 до 6? Логично что два - 5 и 6.

Представим, что у нас есть вещественные числа 5 и 6. Сколько у нас возможных значений от 5 до 6? Бесконенечное количество. 5,0001, 5,327682, 5,9369283493 и т.п. Если мы не задали определенную точность (например максимум 4 знака после запятой), то чисел после запятой может быть бесконечное количество, и каждый раз это будут разные значения.

Чтобы компьютер мог что-то посчитать, числа ему надо выразить в какой-то форме.

Под словом компьютер обычно подразумевается электронный цифровой вычислитель. 

_**Усложняющее уточнение**_
> Почитайте про аналоговые компьютеры, это забавно.

Электронный - значит он работает на электричестве. 

Цифровой - значит он использует всего несколько возможных значений. 

Обычно используют всего два значения - 0 и 1, высокое напряжение и низкое напряжение. Так как значений два, то логика называтся двоичной, или бинарной (binary).

_**Усложняющее уточнение**_
> Есть троичные компьютеры, но у них системотехника сложнее, поэтому и еще в силу ряда причин, они не взлетели.

Все числа выражаются через 0 и 1, только разной длины. 

``` 
0 = 
1 =     |                    
10 =    ||                (2)
11 =    |||               (3)
100 =   ||||              (4)
101 =   |||||             (5)
110 =   ||||||            (6)
111 =   |||||||           (7)
1000 =  ||||||||          (8)
1001 =  |||||||||         (9)
1010 =  ||||||||||        (10)
1011 =  |||||||||||       (11)
1100 =  ||||||||||||      (12)
1101 =  |||||||||||||     (13)
1110 =  ||||||||||||||    (14)
1111 =  |||||||||||||||   (15)
10000 = ||||||||||||||||  (16)
10001 = ||||||||||||||||| (17)
```
Вот так компьютер и представляет числа. Бедняга.

Человеку криво видеть кучу ноликов и единиц, поэтому кроме двоичной, используются восьмеричная и шестнадцатеричная.

Количество знаков, которые нужны, чтобы записать число, называются разрядностью. Максимальное число и разрядность связаны через степень и логарифм.

2 ^ 3 = 8. Два в степени три равно восемь. 

Два - основание степени, у нас всего два значения - 0 и 1.

Три - число знаков. 

Восемь - десятичное максимальное число, которое можно записать в 3 двочиных знаках.

И правда, 111 = 8. 9 будет уже 1000, а это 4 знака.

2 ^ 4 = 16. Числа от 9 до 16 можно записать в 4 знаках. 

16 log (2) = 4. Число 16 можно записать в 4 знаках.

## Размерности

Так как большинство компьютеров используют двоичную систему счисления, то, большинство параметров кратно 2.

Бит - это самая мелкая неделимая (атомарная) единица информации. В двоичной системе это 1 разряд, 1 или 0.

Для определения какой-то вменяемой сущности, например одной буквы, используется величина побольше - байт.

Обычно подразумевается, что 1 байт = 8 бит. 

_**Усложняющее уточнение**_
> В истории компьютерной техники существовали решения с иными размерами байта (например, 6, 32 или 36 бит), поэтому иногда в компьютерных стандартах и официальных документах для однозначного обозначения группы из 8 бит используется термин «октет» (octet). 

_**Усложняющее уточнение**_
> Итак, чтобы записать букву компьютеру в память, нам надо 8 бит. А иногда 16. А иногда 32. Почему так, расскажу попозже.


```
2 ^ 1 =  2
2 ^ 2 =  4 
2 ^ 3 =  8
2 ^ 4 =  16
2 ^ 5 =  32
2 ^ 6 =  64
2 ^ 7 =  128 
2 ^ 8 =  256
2 ^ 9 =  512
2 ^ 10 = 1024
```

Каждый порядок (x10) имеет свое название

|Название   |Обозначение|Степень|
|-----------|-----------|-------|
|байт 	    |Б 	        |2 ^ 0  |
|килобайт 	|Кб 	      |2 ^ 10 |
|мегабайт 	|Мб 	      |2 ^ 20 |
|гигабайт 	|Гб 	      |2 ^ 30	|
|терабайт 	|Тб 	      |2 ^ 40 |
|петабайт 	|Пб 	      |2 ^ 50 |
|эксабайт 	|Эб 	      |2 ^ 70 |
|зеттабайт 	|Зб 	      |2 ^ 80 |
|йоттабайт 	|Иб 	      |2 ^ 90 |

Шутка про то, что 1 терапевт это 1024 гигапевта.

_**Усложняющее уточнение**_
> Вообще правильно, например, 2 ^ 20 называть не Мегабайт, а Мебибайт. 2 ^ 30 не Гигабайт, а Гибибайт. Но на практике никто так не делает.

Только хитрые маркетологи производителей накопителей радуются. В накопителях 1 Гб это не 1024 * 1024 * 1024, а 1000 * 1000 * 1000.


# Разработка

Что такое программирование? 

Это когда придумываешь какой-то алгоритм и описываешь его в коде.

### Пример
Как уже было описано ранее, [компьютер - это тупая железяка](#что-такое-компьютер). 

Представьте прапорщика, которому надо выкопать траншею. В распоряжение ему прислали очень глупого новобранца из далекой республики. Новобранец напрочь лишен чувства самосохранения, не понимает по-русски, но очень старательный и трудолюбивый. Надо объяснить ему как копать, причем он видит лопату первый раз в жизни. 
Прапорщику придется описать алгоритм действий, а потом позвать земляка новобранца, который служит чуть дольше и умеет немного говорить по-русски.
Прапорщик пишет на бумаге
1. Взять лопату руками
2. Воткнуть лопату в землю
3. Надавить ногой
4. Опустить ручку лопаты на себя на 60 градусов
5. Отбросить землю сзади себя

Прапорщик - программист.

Текст на бумажке - программный код. 

Вся сложность разработки в том, что нужно прописать граничные условия. ВСЕ граничные условия.

В примере выше не описано, когда нужно останавиться - новобранец будет копать, пока не выкопает яму в 2 человеческих роста и не засыпет себя в ней.

Значит надо дописать: 

"6. Если яма глубиной на 2 штыка лопаты - сделать шаг вправо"

Теперь новобранец будет копать, пока не упрется в дерево или камень и сломает об него лопату. Дописываем:

"7. Если попалось дерево или камень - обойти его и продолжить копать."

Прапорщика вызвал офицер, и они уехали на другой полигон - новобранец копал, пока не потерял сознание от голода и жажды. 
Дописываем:

"8. Копать отсюда и 100 метров."

## Разновидности языков
Языки разработки делятся на много видов.

* [Интерпретаторы и Компиляторы](#интерпретаторы-и-компиляторы)
* [Высокого уровня и низкого уровня](#высокого-уровня-и-низкого-уровня)
* [Прикладные и системные](#прикладные-и-системные)

### Интерпретаторы и Компиляторы
Земляк-переводчик выступает в роли программы-компилятора (Compiler) или программы-интерпретатора (Interpreter).

#### Компилятор
Земляк-переводчик переписывает текст с русского на родной язык новобранца, отдает перевод и уходит. Из плюсов - один раз перевел и больше не нужен, быстро сработал.

#### Интерпретатор
Земляк-переводчик стоит рядом с текстом и переводит по строкам каждый раз, когда нужно выполнить действие. Из плюсов - можно в любой момент поменять алгоритм (дать новый лист с русским текстом). 

__*Усложняющее уточнение*__
> Сам процесс перевода называется транляцией (Translation).

### Высокого уровня и низкого уровня
Чем подробнее прапорщик должен описывать алгоритм действий, тем язык ниже по уровню.

#### Языки низкого уровня
##### Машинные инструкции
Машинные инструкции - это родной язык новобранца. Представьте что прапорщик научился говорить на этом языке. Замечательно! 

Только этот язык по подробности хуже юридических договоров с банком и мобильным оператором вместе взятых.

Типичные команды, чтобы взять лопату
* Согни руку в локте на 90 градусов
* Растопырь пальцы
* Найди глазами лопату
* Протяни руку в направлении лопаты
* Почувствуй лопату
* Сожми пальцы
* Подтяни лопату к себе

*Усложняющее уточнение*
> Одна команда называется опкод (Operation Code, Instruction Machine Code)

И выглядит язык как говно. 

Пример из Википедии:

> Программа «Hello, world!» для процессора архитектуры x86 (ОС MS DOS, вывод при помощи BIOS прерывания int 10h) выглядит следующим образом (в шестнадцатеричном представлении):\
> `BB 11 01 B9 0D 00 B4 0E 8A 07 43 CD 10 E2 F9 CD 20 48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21`

Ребята-программисты писали на таком годах в 60-х. Прогресс не стоит на месте и у нас есть земляк-переводчик!

##### Ассемблеры

Ассемблер это замена вот этих птичьих цифробукв на человеческие слова

Пример из Википедии, который делает то же самое, что и пример с машинными кодами:

```.MODEL TINY  
CODE SEGMENT  
ASSUME CS:CODE, DS:CODE
ORG 100h
START:
        mov ah,9
        mov dx,OFFSET Msg
        int 21h
        int 20h
        Msg DB 'Hello World',13,10,'$'
CODE ENDS
END START
```

Намного понятнее, конечно. 

Есть много разных процессоров и для каждого из них может быть свой ассемблер. То есть писал разработчик код, а потом вышел новый процессор и код не работает. Отлично вообще. Поэтому на ассемблере обычно что-то под конкретную железяку, например софт (Software, Программное обеспечение) для самолетов и космических кораблей. Ну и вирусы, куда ж без них. 

А еще есть понятие демо-сцены. Это когда пацаны угорают, кто сделает красивее какой-нибудь мультик и при этом меньше размером. Рекомендую посмотреть на ютубе ролики победителей демо-сцены, это пушка.

#### Языки высокого уровня

Языки высокого уровня гораздо приятнее для разработчика. Некоторые позволяют прапорщику сказать что-то вроде: "Сделай траншею длиной 100 м, шириной 1 м и глубиной 0,5 м. Как сделаешь, доложишь.". И все! Но надо понимать, что за этой кажущейся легкостью лежит целое поле сложных уточнений. Это не новобранец стал умнее, а переводчик понял задание, и дополнил его подробными действиями в той или иной ситуации. В итоге 3 слова прапорщика превращается в 50 страниц текста переводчика. Или в 100. Или в 300. Сложность компиляторов постоянно растет, но вычислительная мощность компьютеров тоже постоянно растет, поэтому в среднем сидим ровно.

Раньше один  человек строил землянку за неделю.

Потом изобрели топор - стал строить хижину за неделю.

Потом изобрели кирпич - стали впятером строить дом за неделю.

Потом изобрели монолитное литье, подьемные краны и бригады строителей по 50 человек - и строят многоэтажный дом за ту же неделю.

##### Парадигмы
Для создателей языков программирования развернулось широкое поле экспериментов. Общие правила и подходы, как надо писать код на конкретном языке, называются парадигмами. Некоторые умные дядьки, писали статьи, в которыех доказывали, почему писать код надо вот именно так, а не иначе. Например Э. Дейкстра, Д. Кнут.

__*Усложняющее уточнение*__
Существуюет книжка Питера Сейбела «Кодеры за работой», там он общается с известными дядьками, насчет их взгляда на развитие программирования.

Основных широко используемых парадигм всего 3:
* Процедурная
* Функциональная
* Объектно-ориентированная (ООП)


#### Прикладные и системные

Программное обеспечение делится на прикладное (**application software**) и системное (**system software**). К системному относятся например операционные системы, утилиты операционных систем, драйвера. Приладное - текстовые и графические редакторы, игры, браузеры, плееры. 

Если на языке можно написать системное ПО, то он системный.

## Объектно-ориентированное программирование
Одной из самых распространенных парадигм разработки является ООП - Объктно-ориентированное программирование (Object-oriented programming).

ООП состоит из 3 основных понятий
* Инкапсуляция
* Наследование 
* Полиморфизм

И еще Абстракция (Abstraction).

### Абстракция
#### Классы и экземпляры
Смысл абстракции в том, что все - суть есть объект. Не так уж далеко от истины.

Мы выходим на улицу и видим машины. Одна мерседес, другая красная, третья грузовик. Главное что их объединяет - то, что они машины. 

Значит можно выделить *класс* Машины. Класс - это как чертеж, общее описание некого объекта или группы объектов. 

Если мы говорим про конкретную машину, которая стоит и существует перед нами, то это *объект* или *экземпляр* класса Машины. 

И так со всем:
* есть коты, а есть вот этот конкретный рыжий кот
* есть дома, а есть конкретный дом, с адресом и красной крышей
* есть винтовки, а это моя винтовка. Таких винтовок много, но именно эта — моя. Моя винтовка — мой лучший друг... 

### Инкапсуляция

_**Усложняющее уточнение**_
> В некоторых языках программирования Абстракция является частью Инкапсуляции, а в некоторых это разные понятия.

#### Данные и методы
У объекта есть данные и методы.

Данные - то что характеризует объект. Номер, вес, длина, ширина, высота, цвет, запах - это все данные.
Данные должны в одинаковом количестве присутствовать у всех экземпляров одного класса, это их объединяющие признаки. Не значения данных, а именно сами данные. Если у объекта 653 характеристики, то у другого объекта этого же класса будет 653 точно таких же характеристики.

Например, у всех собак есть цвет. Одна черная, другая серая, третья в крапинку. Но так, чтобы у одной собаки был цвет, а у другой нет - не бывает. Если увидите прозрачную собаку, дайте мне знать, я исправлю пример.

Методы - поведение объекта, как с ним можно взаимодействовать. Какие глаголы можно применить к объекту, это и есть методы. В машине можно ехать, в доме можно жить. В принципе в машине тоже можно жить, но она все-таки мало похожа на дом.

Самое интересное то, что методы у всех объектов одинаковы, но результат выполнения разный, потому что методы используют данные конкретного объекта.

Например есть 2 машины, одна весит 1200 кг и мотор 600 л.с., а вторая весит 3000 кг и мотор 90 л.с. У обеих есть метод Ехать, но результаты будут разные. 

#### Сокрытие
Сокрытие (Information hiding) или Область видимости (Scope), (также Модификаторы доступа (Access modifiers)) - это очень важная штука, которая помогает управлять сложностью. 

Любой механизм сложнее молотка предоставляет какие-то органы управления, а реализацию скрывает внутри. 

Например, радио. Можно разложить все компоненты на столе, замыкать контакты отверткой, а громкость регулировать быстро-быстро подменяя резисторы. Но это слегка неудобно. Гораздо приятнее собрать все в компактный корпус и вынести рукоятки управления громкости и частоты - это и есть сокрытие реализации.

Радио для обычного пользователя представляет собой Черный ящик (Black box). Имеются некоторые входные данные - электричество, радиоволны, настройка частоты и громкости. Все это каким-то образом обрабатывается внутри корпуса, и получаются выходные данные - звуки музыки или передачи. 

Обычно,если входные и выходные данные корректны, то внутрь ящика заглядывают редко. Если телевизор работает исправно, то зачем его разбирать? Разве что из любопытства. 

Если представить радио как объект, то у него будут данные и методы.
Данные:
* Индикатор питания
* Индикатор громкости
* Индикатор частоты

Методы:
* Изменение громкости
* Изменение частоты
* Включить/выключить

Внутри радио происходит еще куча процессов, например фильтрация помех. 

Еще методы:
* Фильтрация помех

Но эти данные и методы не видны, потому что они скрыты!

Ручки управления и индикаторы имеют Область видимости вне корпуса, таким данным и методам обычно соответствует модификатор доступа public. Внутренние процессы имеют область видимости гораздо меньше, они ограничены корпусом, таким данным и методам обычно соответствует модификатор доступа private. 

Получается, что объект Радио имеют следующие методы:
* public Изменение громкости
* public Изменение частоты
* public Включить/выключить
* private Фильтрация помех

Самое важное то, что с точки зрения самого радио все эти методы в общем-то одинаковы, они все имеют доступ к данным. Сокрытие нужно не для самого радио, а для потребителя радио как черного ящика. 

Люди обычно не задумываются, как именно устроен лифт, телефон, телевизор, а просто пользуются ими через открытые методы.

Сокрытие уменьшает сложность использования. Каждый черный ящик содержит в себе несколько более примитивных черных ящиков и просто использует их. Использование различных вещей как черных ящиков позволяет создавать потрясающие по сложности вещи, например небоскребы, космические корабли и программное обеспечение.

### Полиморфизм
#### Интерфейсы
Если открытые (public) методы и данные одинаковы у разных классов, то это значит что у них одинаковый Интерфейс (Interface).

Если человек научился управлять одним легковым автомобилем, то скорее всего он сядет в совершенно другой автомобиль и спокойно поедет. Это потому что у легковых автомобилей есть стандартный интерфейс управления - руль, педали, ручка коробки передач. При этом реализация мотора может быть абсолютно разной - бензиновый, дизельный, электрический, водородный. 

В этом как раз и заключается полиморфизм - один интерфейс, много реализаций. 

