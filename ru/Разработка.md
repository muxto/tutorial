Содержание 
* [Введение](#введение)
* [Разновидности языков](#разновидности-языков)
* [ООП](#объектно-ориентированное-программирование)
  * [Абстракция](#абстракция)
  * [Инкапсуляция](#инкапсуляция)
  * [Полиморфизм](#Полиморфизм)
  
# Введение

Что такое программирование? 

Это когда придумываешь какой-то алгоритм и описываешь его в коде.

## Пример
Как уже было описано ранее, [компьютер - это тупая железяка](./../Общее.md#компьютер.md). 

Представьте прапорщика, которому надо выкопать траншею. В распоряжение ему прислали очень глупого новобранца из далекой республики. Новобранец напрочь лишен чувства самосохранения, не понимает по-русски, но очень старательный и трудолюбивый. Надо объяснить ему как копать, причем он видит лопату первый раз в жизни. 
Прапорщику придется описать алгоритм действий, а потом позвать земляка новобранца, который служит чуть дольше и умеет немного говорить по-русски.
Прапорщик пишет на бумаге
1. Взять лопату руками
2. Воткнуть лопату в землю
3. Надавить ногой
4. Опустить ручку лопаты на себя на 60 градусов
5. Отбросить землю сзади себя

Прапорщик - программист.

Текст на бумажке - программный код. 

Вся сложность разработки в том, что нужно прописать граничные условия. ВСЕ граничные условия.

В примере выше не описано, когда нужно останавиться - новобранец будет копать, пока не выкопает яму в 2 человеческих роста и не засыпет себя в ней.

Значит надо дописать: 

"6. Если яма глубиной на 2 штыка лопаты - сделать шаг вправо"

Теперь новобранец будет копать, пока не упрется в дерево или камень и сломает об него лопату. Дописываем:

"7. Если попалось дерево или камень - обойти его и продолжить копать."

Прапорщика вызвал офицер, и они уехали на другой полигон - новобранец копал, пока не потерял сознание от голода и жажды. 
Дописываем:

"8. Копать отсюда и 100 метров."

# Разновидности языков
Языки разработки делятся на много видов.

## Интерпретаторы и Компиляторы
Земляк-переводчик выступает в роли программы-компилятора (Compiler) или программы-интерпретатора (Interpreter).

### Компилятор
Земляк-переводчик переписывает текст с русского на родной язык новобранца, отдает перевод и уходит. Из плюсов - один раз перевел и больше не нужен, быстро сработал.

### Интерпретатор
Земляк-переводчик стоит рядом с текстом и переводит по строкам каждый раз, когда нужно выполнить действие. Из плюсов - можно в любой момент поменять алгоритм (дать новый лист с русским текстом). 

__*Усложняющее уточнение*__
> Сам процесс перевода называется транляцией (Translation).

## Высокого уровня и низкого уровня
Чем подробнее прапорщик должен описывать алгоритм действий, тем язык ниже по уровню.

### Языки низкого уровня
#### Машинные инструкции
Машинные инструкции - это родной язык новобранца. Представьте что прапорщик научился говорить на этом языке. Замечательно! 

Только этот язык по подробности хуже юридических договоров с банком и мобильным оператором вместе взятых.

Типичные команды, чтобы взять лопату
* Согни руку в локте на 90 градусов
* Растопырь пальцы
* Найди глазами лопату
* Протяни руку в направлении лопаты
* Почувствуй лопату
* Сожми пальцы
* Подтяни лопату к себе

*Усложняющее уточнение*
> Одна команда называется опкод (Operation Code, Instruction Machine Code)

И выглядит язык как говно. 

Пример из Википедии:

> Программа «Hello, world!» для процессора архитектуры x86 (ОС MS DOS, вывод при помощи BIOS прерывания int 10h) выглядит следующим образом (в шестнадцатеричном представлении):\
> `BB 11 01 B9 0D 00 B4 0E 8A 07 43 CD 10 E2 F9 CD 20 48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21`

Ребята-программисты писали на таком годах в 60-х. Прогресс не стоит на месте и у нас есть земляк-переводчик!

#### Ассемблеры

Ассемблер это замена вот этих птичьих цифробукв на человеческие слова

Пример из Википедии, который делает то же самое, что и пример с машинными кодами:

```.MODEL TINY  
CODE SEGMENT  
ASSUME CS:CODE, DS:CODE
ORG 100h
START:
        mov ah,9
        mov dx,OFFSET Msg
        int 21h
        int 20h
        Msg DB 'Hello World',13,10,'$'
CODE ENDS
END START
```

Намного понятнее, конечно. 

Есть много разных процессоров и для каждого из них может быть свой ассемблер. То есть писал разработчик код, а потом вышел новый процессор и код не работает. Отлично вообще. Поэтому на ассемблере обычно что-то под конкретную железяку, например софт (Software, Программное обеспечение) для самолетов и космических кораблей. Ну и вирусы, куда ж без них. 

А еще есть понятие демо-сцены. Это когда пацаны угорают, кто сделает красивее какой-нибудь мультик и при этом меньше размером. Рекомендую посмотреть на ютубе ролики победителей демо-сцены, это пушка.

### Языки высокого уровня

Языки высокого уровня гораздо приятнее для разработчика. Некоторые позволяют прапорщику сказать что-то вроде: "Сделай траншею длиной 100 м, шириной 1 м и глубиной 0,5 м. Как сделаешь, доложишь.". И все! Но надо понимать, что за этой кажущейся легкостью лежит целое поле сложных уточнений. Это не новобранец стал умнее, а переводчик понял задание, и дополнил его подробными действиями в той или иной ситуации. В итоге 3 слова прапорщика превращается в 50 страниц текста переводчика. Или в 100. Или в 300. Сложность компиляторов постоянно растет, но вычислительная мощность компьютеров тоже постоянно растет, поэтому в среднем сидим ровно.

Раньше один  человек строил землянку за неделю.

Потом изобрели топор - стал строить хижину за неделю.

Потом изобрели кирпич - стали впятером строить дом за неделю.

Потом изобрели монолитное литье, подьемные краны и бригады строителей по 50 человек - и строят многоэтажный дом за ту же неделю.

#### Парадигмы
Для создателей языков программирования развернулось широкое поле экспериментов. Общие правила и подходы, как надо писать код на конкретном языке, называются парадигмами. Некоторые умные дядьки, писали статьи, в которыех доказывали, почему писать код надо вот именно так, а не иначе. Например Э. Дейкстра, Д. Кнут.

__*Усложняющее уточнение*__
Существуюет книжка Питера Сейбела «Кодеры за работой», там он общается с известными дядьками, насчет их взгляда на развитие программирования.

Основных широко используемых парадигм всего 3:
* Процедурная
* Функциональная
* Объектно-ориентированная (ООП)

# Объектно-ориентированное программирование
Одной из самых распространенных парадигм разработки является ООП - Объктно-ориентированное программирование (Object-oriented programming).

ООП состоит из 3 основных понятий
* Инкапсуляция
* Наследование 
* Полиморфизм

И еще Абстракция (Abstraction).

## Абстракция
### Классы и экземпляры
Смысл абстракции в том, что все - суть есть объект. Не так уж далеко от истины.

Мы выходим на улицу и видим машины. Одна мерседес, другая красная, третья грузовик. Главное что их объединяет - то, что они машины. 

Значит можно выделить *класс* Машины. Класс - это как чертеж, общее описание некого объекта или группы объектов. 

Если мы говорим про конкретную машину, которая стоит и существует перед нами, то это *объект* или *экземпляр* класса Машины. 

И так со всем:
* есть коты, а есть вот этот конкретный рыжий кот
* есть дома, а есть конкретный дом, с адресом и красной крышей
* есть винтовки, а это моя винтовка. Таких винтовок много, но именно эта — моя. Моя винтовка — мой лучший друг... 

## Инкапсуляция

_**Усложняющее уточнение**_
> В некоторых языках программирования Абстракция является частью Инкапсуляции, а в некоторых это разные понятия.

### Данные и методы
У объекта есть данные и методы.

Данные - то что характеризует объект. Номер, вес, длина, ширина, высота, цвет, запах - это все данные.
Данные должны в одинаковом количестве присутствовать у всех экземпляров одного класса, это их объединяющие признаки. Не значения данных, а именно сами данные. Если у объекта 653 характеристики, то у другого объекта этого же класса будет 653 точно таких же характеристики.

Например, у всех собак есть цвет. Одна черная, другая серая, третья в крапинку. Но так, чтобы у одной собаки был цвет, а у другой нет - не бывает. Если увидите прозрачную собаку, дайте мне знать, я исправлю пример.

Методы - поведение объекта, как с ним можно взаимодействовать. Какие глаголы можно применить к объекту, это и есть методы. В машине можно ехать, в доме можно жить. В принципе в машине тоже можно жить, но она все-таки мало похожа на дом.

Самое интересное то, что методы у всех объектов одинаковы, но результат выполнения разный, потому что методы используют данные конкретного объекта.

Например есть 2 машины, одна весит 1200 кг и мотор 600 л.с., а вторая весит 3000 кг и мотор 90 л.с. У обеих есть метод Ехать, но результаты будут разные. 

### Сокрытие
Сокрытие (Information hiding) или Область видимости (Scope), (также Модификаторы доступа (Access modifiers)) - это очень важная штука, которая помогает управлять сложностью. 

Любой механизм сложнее молотка предоставляет какие-то органы управления, а реализацию скрывает внутри. 

Например, радио. Можно разложить все компоненты на столе, замыкать контакты отверткой, а громкость регулировать быстро-быстро подменяя резисторы. Но это слегка неудобно. Гораздо приятнее собрать все в компактный корпус и вынести рукоятки управления громкости и частоты - это и есть сокрытие реализации.

Радио для обычного пользователя представляет собой Черный ящик (Black box). Имеются некоторые входные данные - электричество, радиоволны, настройка частоты и громкости. Все это каким-то образом обрабатывается внутри корпуса, и получаются выходные данные - звуки музыки или передачи. 

Обычно,если входные и выходные данные корректны, то внутрь ящика заглядывают редко. Если телевизор работает исправно, то зачем его разбирать? Разве что из любопытства. 

Если представить радио как объект, то у него будут данные и методы.
Данные:
* Индикатор питания
* Индикатор громкости
* Индикатор частоты

Методы:
* Изменение громкости
* Изменение частоты
* Включить/выключить

Внутри радио происходит еще куча процессов, например фильтрация помех. 

Еще методы:
* Фильтрация помех

Но эти данные и методы не видны, потому что они скрыты!

Ручки управления и индикаторы имеют Область видимости вне корпуса, таким данным и методам обычно соответствует модификатор доступа public. Внутренние процессы имеют область видимости гораздо меньше, они ограничены корпусом, таким данным и методам обычно соответствует модификатор доступа private. 

Получается, что объект Радио имеют следующие методы:
* public Изменение громкости
* public Изменение частоты
* public Включить/выключить
* private Фильтрация помех

Самое важное то, что с точки зрения самого радио все эти методы в общем-то одинаковы, они все имеют доступ к данным. Сокрытие нужно не для самого радио, а для потребителя радио как черного ящика. 

Люди обычно не задумываются, как именно устроен лифт, телефон, телевизор, а просто пользуются ими через открытые методы.

Сокрытие уменьшает сложность использования. Каждый черный ящик содержит в себе несколько более примитивных черных ящиков и просто использует их. Использование различных вещей как черных ящиков позволяет создавать потрясающие по сложности вещи, например небоскребы, космические корабли и программное обеспечение.

## Полиморфизм
### Интерфейсы
Если открытые (public) методы и данные одинаковы у разных классов, то это значит что у них одинаковый Интерфейс (Interface).

Если человек научился управлять одним легковым автомобилем, то скорее всего он сядет в совершенно другой автомобиль и спокойно поедет. Это потому что у легковых автомобилей есть стандартный интерфейс управления - руль, педали, ручка коробки передач. При этом реализация мотора может быть абсолютно разной - бензиновый, дизельный, электрический, водородный. 

В этом как раз и заключается полиморфизм - один интерфейс, много реализаций. 



