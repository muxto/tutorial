Содержание 
* [Введение](#введение)
* [Разновидности языков](#разновидности-языков)

# Введение

Что такое программирование? 

Это когда придумываешь какой-то алгоритм и описываешь его в коде.

## Пример
Как уже было описано в статье [Компьютер](./../Общее.md#компьютер.md), компьютер это тупая железяка. 

Представьте прапорщика, которому надо выкопать траншею. В распоряжение ему прислали очень глупого новобранца из далекой республики. Новобранец напрочь лишен чувства самосохранения, не понимает по-русски, но очень старательный и трудолюбивый. Надо объяснить ему как копать, причем он видит лопату первый раз в жизни. 
Прапорщику придется описать алгоритм действий, а потом позвать земляка новобранца, который служит чуть дольше и умеет немного говорить по-русски.
Прапорщик пишет на бумаге
1. Взять лопату руками
2. Воткнуть лопату в землю
3. Надавить ногой
4. Опустить ручку лопаты на себя на 60 градусов
5. Отбросить землю сзади себя

Прапорщик - программист.

Текст на бумажке - программный код. 

Вся сложность разработки в том, что нужно прописать граничные условия. ВСЕ граничные условия.

В примере выше не описано, когда нужно останавиться - новобранец будет копать, пока не выкопает яму в 2 человеческих роста и не засыпет себя в ней.

Значит надо дописать: 

"6. Если яма глубиной на 2 штыка лопаты - сделать шаг вправо"

Теперь новобранец будет копать, пока не упрется в дерево или камень и сломает об него лопату. Дописываем:

"7. Если попалось дерево или камень - обойти его и продолжить копать."

Прапорщика вызвал офицер, и они уехали на другой полигон - новобранец копал, пока не потерял сознание от голода и жажды. 
Дописываем:

"8. Копать отсюда и 100 метров."

# Разновидности языков
Языки разработки делятся на много видов.
Продолжим пример про прапорщика (разработчика) и новобранца (процессора) из главы [Введение](Введение.md).

## Интерпретаторы и Компиляторы
Земляк-переводчик выступает в роли программы-компилятора (Compiler) или программы-интерпретатора (Interpreter).

### Компилятор
Земляк-переводчик переписывает текст с русского на родной язык новобранца, отдает перевод и уходит. Из плюсов - один раз перевел и больше не нужен, быстро сработал.

### Интерпретатор
Земляк-переводчик стоит рядом с текстом и переводит по строкам каждый раз, когда нужно выполнить действие. Из плюсов - можно в любой момент поменять алгоритм (дать новый лист с русским текстом). 

__*Усложняющее уточнение*__
> Сам процесс перевода называется транляцией (Translation).

## Высокого уровня и низкого уровня
Чем подробнее прапорщик должен описывать алгоритм действий, тем язык ниже по уровню.

### Языки низкого уровня
#### Машинные инструкции
Машинные инструкции - это родной язык новобранца. Представьте что прапорщик научился говорить на этом языке. Замечательно! 

Только этот язык по подробности хуже юридических договоров с банком и мобильным оператором вместе взятых.

Типичные команды, чтобы взять лопату
* Согни руку в локте на 90 градусов
* Растопырь пальцы
* Найди глазами лопату
* Протяни руку в направлении лопаты
* Почувствуй лопату
* Сожми пальцы
* Подтяни лопату к себе

*Усложняющее уточнение*
> Одна команда называется опкод (Operation Code, Instruction Machine Code)

И выглядит язык как говно. 

Пример из Википедии:

> Программа «Hello, world!» для процессора архитектуры x86 (ОС MS DOS, вывод при помощи BIOS прерывания int 10h) выглядит следующим образом (в шестнадцатеричном представлении):\
> `BB 11 01 B9 0D 00 B4 0E 8A 07 43 CD 10 E2 F9 CD 20 48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21`

Ребята-программисты писали на таком годах в 60-х. Прогресс не стоит на месте и у нас есть земляк-переводчик!

#### Ассемблеры

Ассемблер это замена вот этих птичьих цифробукв на человеческие слова

Пример из Википедии, который делает то же самое, что и пример с машинными кодами:

```.MODEL TINY  
CODE SEGMENT  
ASSUME CS:CODE, DS:CODE
ORG 100h
START:
        mov ah,9
        mov dx,OFFSET Msg
        int 21h
        int 20h
        Msg DB 'Hello World',13,10,'$'
CODE ENDS
END START
```

Намного понятнее, конечно. 

Есть много разных процессоров и для каждого из них может быть свой ассемблер. То есть писал разработчик код, а потом вышел новый процессор и код не работает. Отлично вообще. Поэтому на ассемблере обычно что-то под конкретную железяку, например софт (Software, Программное обеспечение) для самолетов и космических кораблей. Ну и вирусы, куда ж без них. 

А еще есть понятие демо-сцены. Это когда пацаны угорают, кто сделает красивее какой-нибудь мультик и при этом меньше размером. Рекомендую посмотреть на ютубе ролики победителей демо-сцены, это пушка.

### Языки высокого уровня

Языки высокого уровня гораздо приятнее для разработчика. Некоторые позволяют прапорщику сказать что-то вроде: "Сделай траншею длиной 100 м, шириной 1 м и глубиной 0,5 м. Как сделаешь, доложишь.". И все! Но надо понимать, что за этой кажущейся легкостью лежит целое поле сложных уточнений. Это не новобранец стал умнее, а переводчик понял задание, и дополнил его подробными действиями в той или иной ситуации. В итоге 3 слова прапорщика превращается в 50 страниц текста переводчика. Или в 100. Или в 300. Сложность компиляторов постоянно растет, но вычислительная мощность компьютеров тоже постоянно растет, поэтому в среднем сидим ровно.

Раньше один  человек строил землянку за неделю.

Потом изобрели топор - стал строить хижину за неделю.

Потом изобрели кирпич - стали впятером строить дом за неделю.

Потом изобрели монолитное литье, подьемные краны и бригады строителей по 50 человек - и строят многоэтажный дом за ту же неделю.

#### Парадигмы
Для создателей языков программирования развернулось широкое поле экспериментов. Общие правила и подходы, как надо писать код на конкретном языке, называются парадигмами. Некоторые умные дядьки, писали статьи, в которыех доказывали, почему писать код надо вот именно так, а не иначе. Например Э. Дейкстра, Д. Кнут.

__*Усложняющее уточнение*__
Существуюет книжка Питера Сейбела «Кодеры за работой», там он общается с известными дядьками, насчет их взгляда на развитие программирования.

Основных широко используемых парадигм всего 3:
* Процедурная
* Функциональная
* Объектно-ориентированная (ООП)




